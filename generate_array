#!/usr/bin/perl -w

use strict;

my $configFile = "generate_array.conf";

my %userPrefs;
my %inputValues;

sub readConfig() {

	(-f $configFile ) || die "Config file: $configFile not found.\n";

	open CONFIG, $configFile;

	while (<CONFIG>) {
	    	chomp;                  # no newline
    		s/#.*//;                # no comments
    		s/^\s+//;               # no leading white
    		s/\s+$//;               # no trailing white
    		next unless length;     # anything left?
    		my ($var, $value) = split(/\s*=\s*/, $_, 2);
    		$userPrefs{$var} = $value;
	}
}

sub getUserInput() {

	$inputValues{'units'} = "";

	while (($inputValues{'units'} ne "i") && ($inputValues{'units'} ne "m")) {
		$inputValues{'units'} = lc(promptUser("Units - (i)nches (m)illimeters ",($userPrefs{'units'} eq 'inches' ? "i" : "m")));
	}

	$inputValues{'end_mill_dia'} = promptUser("End mill diameter ",$userPrefs{'end_mill_dia'});
	$inputValues{'mill_dir'} = promptUser("Circle direction (ccw/cw) ",$userPrefs{'mill_dir'});
	$inputValues{'pass_overlap'} = promptUser("Step over percentage ",$userPrefs{'pass_overlap'});
	$inputValues{'safety_plane'} = promptUser("Safety plane height ",$userPrefs{'safety_plane'});
	$inputValues{'hole_dia'} = promptUser("Hole diameter ",$userPrefs{'hole_diameter'});
	$inputValues{'hole_depth'} = promptUser("Hole depth ",$userPrefs{'hole_depth'});
	$inputValues{'plunge_depth'} = promptUser("Plunge depth ",$userPrefs{'plunge_depth'});
	$inputValues{'x_origin'} = promptUser("X origin ", $userPrefs{'x_origin'});
	$inputValues{'y_origin'} = promptUser("Y origin ", $userPrefs{'y_origin'});
	$inputValues{'z_origin'} = promptUser("Z origin ", $userPrefs{'z_origin'});
	$inputValues{'x_count'} = promptUser("Number of columns (X axis) ", $userPrefs{'x_count'});
	$inputValues{'y_count'} = promptUser("Number of rows (Y axis) ", $userPrefs{'y_count'});
	$inputValues{'x_spacing'} = promptUser("X spacing ", $userPrefs{'x_spacing'});
	$inputValues{'y_spacing'} = promptUser("Y spacing ", $userPrefs{'y_spacing'});
	$inputValues{'comments'} = promptUser("Comments ");
	$inputValues{'filename'} = promptUser("Output file name (leave blank for stdout)");
}

sub sanityCheck() {

	## Lets make sure some of these values make sense
	($inputValues{'hole_dia'} <= $inputValues{'end_mill_dia'}) && die "Your specified end mill is larger than the hole diameter\n";

	if ($inputValues{'filename'} ne "" ) {
		my $overwrite = "n";
		while((-f $inputValues{'filename'}) && ($overwrite eq 'n')) {
			$overwrite = lc(promptUser("Output file $inputValues{'filename'} already exists, would you like to overwrite it? ","N"));
			if ($overwrite eq 'n') {
				$inputValues{'filename'} = promptUser("Please enter a new output file name ");
			}
		}

		open TEST, $inputValues{'filename'} || die "Unable to open output file: $inputValues{'filename'}, $?\n";
		close TEST;
	}
}

sub calculateGcode() {

	if ($inputValues{'filename'} ne "") {
		open (OUTFILE,">$inputValues{'filename'}") || die "Unable to open output file: $inputValues{'filename'}, $?\n";
	} else {
		open (OUTFILE,"><stdout>");
	}

	my $currentX = $inputValues{'x_origin'};
	my $currentY = $inputValues{'y_origin'};
	my $currentZ = $inputValues{'z_origin'};

	# output some header stuff
	print OUTFILE "(Created with generate_array)\n";
	if ($inputValues{'units'} eq 'i') {
		print OUTFILE "G20 ";
	} else {
		print OUTFILE "G21 ";
	}
	print OUTFILE "G90 G40\n";
	print OUTFILE "G00 Z" . $inputValues{'safety_plane'} . "\n";
	
	my $column = 1;
	my $row = 1;

	while ($row <= $inputValues{'y_count'}) {
		while ($column <= $inputValues{'x_count'}){
			print OUTFILE "G00 X" . $currentX . " Y" . $currentY . "\n";
			generateCircle($currentX, $currentY, \*OUTFILE);
			$currentX = $currentX + $inputValues{'x_spacing'};
			$column++;
		}
		$currentY = $currentY + $inputValues{'y_spacing'};
		$row++;
		$column = 1;
		$currentX = $inputValues{'x_origin'};
	}

	close OUTFILE;
}

sub promptUser {

	  my($prompt, $default) = @_;
	  my $defaultValue = defined($default) ? "[$default]" : "";
	  print "$prompt $defaultValue: ";
	  chomp(my $input = <STDIN>);
	  return $input ? $input : $default;
}

sub generateCircle {
	my ($xOrigin, $yOrigin, $FILE) = @_;
	print $FILE "(begining hole boring)\n";

	# do some cutter step over math here
	my $stepOver = $inputValues{'pass_overlap'} / $inputValues{'end_mill_dia'};
	my $holeRadius = $inputValues{'hole_dia'} / 2;
	mY $cutterRadius = $inputValues{'end_mill_dia'} /2;

	my $currentZ = $inputValues{'z_origin'};
	my $finalZ = $currentZ - $inputValues{'hole_depth'}';

	## It is recommended to generate circles using multiple arcs
	## so we will do four 90 degree arcs

	while ($currentZ >= $finalZ) {
		print $File "G01 F" . $inputValues{'plunge_rate'} . " Z" . $currentZ . "\n";

		if (( $holeRadius - $cutterRadius ) <= $stepOver)) {
			# single pass will clean it up
			## TODO add finish path logic
			# move to the start point of the hole
			print $FILE "G01 F" . $inputValues{'feed_rate'} . " X" . $xOrigin - ($holeRadius - $cutterRadius) ' "\n";
			if ( $inputValues{'mill_dir'} eq 'ccw' ) {
				print $FILE "G03 ";
			} else {
				print $FILE "G02 ";
			}
	}
		
}

readConfig();
getUserInput();
sanityCheck();
calculateGcode();

## TODO
## more input validation
